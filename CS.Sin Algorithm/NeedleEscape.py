'''
세 겹의 선분은 거리 1씩 위 아래로 떨어져 있고, 작은 구멍들이 뚫려져 있다. Needle은 자신의 긴 몸을 이 구멍들에 맞춰 통과해야만 반대로 갈 수 있다.(반드시 구멍을 통과해야하고 바늘은 휘어지지 않는다.)

입력:
첫째 줄: 가장 윗 장벽 선분의 구멍 수 u
둘재 줄: 가장 윗 장벽에 있는 구멍의 x 좌표를 나타내는 u개의 정수
세째 줄: 중간 장벽 선분의 구멍 수 m
넷째 줄: 중간 장벽에 있는 구멍의 x-좌표를 나타내는 m개의 정수
다섯째 줄: 가장 아래 장벽 선분의 구멍 수 l
여섯째 줄: 가장 아래 장벽에 있는 구멍의 x-좌표를 나타내는 l개의 정수

출력:
지나갈 수 있는 경우의 수
'''

'''
아래 방식은 메모리를 많이 사용하지만 조금은 시간복잡도를 줄일 수 있는 방법을 고안하였다. 우선 편한 계산을 위해 모든 줄에 구멍을 정렬해준다.
가운데 줄 구멍에 해당하는 인덱스를 1로 저장해주는 리스트를 하나 추가로 생성하였다. 이 과정에서 ulogu, llogl, mlogm, 60000 상수 시간만큼
계산이 소요된다.
이 후 가장 첫 줄에 구멍을 기준으로 마지막 줄 칸과 연결했을 때 미리 인덱스화 시켜둔 중간줄 구멍값과 대조해서 값을 구한다. 선형탐색 혹은 이진탐색을 하는 경우보다 메모리는 많이 사용하지만 시간은 줄어든다.
이는 UL만큼의 시간이 걸린다.
전체 시간복잡도를 계산한다면 60000 + ulogu + llogl + mlogm + ul이 걸린다. 이를 빅 O로 표기하면 O(n^2)으로 볼 수 있다. 
'''
def counting(a, M, L):
    cnt = 0

    for i in range(len(L)):
        if (a+L[i]) % 2 == 1:  # 모두 정수이므로 홀수를 2로 나눠도 가운데 줄을 통과하지 못하므로 패스
            continue

        if idx[int((a+L[i])/2 + 30000)] == 1:  # M 리스트를 확인했을 때 그 점을 지난다면 카운팅
            cnt += 1

    return cnt

# 입력파트
u = int(input())
U = list(map(int, input().split()))
m = int(input())
M = list(map(int, input().split()))
l = int(input())
L = list(map(int, input().split()))

# Main
count = 0

U.sort()
M.sort()
L.sort()

idx = []
for i in range(60001):  # 가운데 줄 인덱스를 모두 0으로 초기화 해서 총 60000개를 생성
    idx.append(0)

for i in range(len(M)):  # 그 중 지나갈 수 있는 인덱스만 1로 변경해준다. 이 때 인덱스값은 양수로 저장되므로 모두 30000을 더해준다.
    idx[M[i]+30000] = 1

for i in range(0, u): # 들어가는 구멍을 기준으로 나가는 구멍을 가장 바깥쪽 구멍으로 잡았을 때 그 두 선 사이에 M값이 없다면 패스한다.
    m1 = (U[i] + L[0]) / 2
    m2 = (U[i] + L[l - 1]) / 2
    if M[0] <= m1 <= M[m - 1] or M[0] <= m2 <= M[m - 1]:
        count += counting(U[i], idx, L)
    else:
        continue

print(count)
