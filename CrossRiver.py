'''
폭이 L인 강에 n개의 돌로 구성된 징검다리가 있다. 시작 위치가 0이고 강 건너편 끝나는 위치는 L이 된다.
인접한 돌 사이를 점프해 건너야 하는데, 인접한 돌 사이의 최소 거리 이상 점프를 해야 한다. 물론 시작 위치 0에서 첫 번째 돌까지의 거리와 마지막 돌에서 위치 L까지의 거리도 고려해야한다.
문제는 강 폭 L, n개의 돌 위치, 뺄 수 있는 돌의 최대 개수 k가 입력으로 주어지면, 징검다리를 건너기 위해 필요한 점프의 값을 최대가 되도록 K개의 돌을 빼는 것이다. 

입력:
첫 줄에 세 개의 자연수 L, n, k이 주어진다. 두 번째 줄에는 n개의 돌의 위치가 오름차순으로 정렬, 같은 위치에 두개의 돌은 놓지 안흔ㄴ다.

출력:
징검다리를 건너기 위해 필요한 점프 값이 최대가 되도록 최대 k개의 돌을 빼야한다. 이 최대 점프 값을 출력한다.
'''

'''
최솟값을 미리 지정해놓고 이분탐색을 실행한다. mid(임의로 지정해준 최솟값)를 지정하고 바위를 제거했을 때 제거된 바위의 수가 제거할 수 있는 최대값인 k보다 크다면 mid값을 더 줄여서 계산, 제거된 바위가 k보다 작아 더 제거할 수 있다면 mid값을 더 늘려서 계산한다. 마지막으로 k값과 값이 동일하다면 더 이상 연산을 해 볼 필요없이 그때가 최적의 최솟값이다.
while 문 연산은 최악의 경우 logL, 그 안에서 tmp를 구하기 위해 사용한 max함수가 O(n) 반복문 하나가 O(n)으로 최악의 경우 시간복잡도는 O(NlogL)만큼이 걸린다.
'''

L, n, k = map(int, input().split())
A = list(map(int, input().split()))

A.append(L)

left = 0
right = L
while right - left >= 0:
	mid = (right+left) // 2
	tmp = max(A) + 1  # 나올 수 있는 최대 거리+1이므로 이보다 큰 수는 나올 수 없다
	loc = 0  # 기준 돌
	cnt = 0  # 제거한 돌의 개수
	
	for rock in A:
		diff = rock - loc
		if diff < mid:  # 지정해준 최솟값보다 작다면 돌을 제거해준다
			cnt += 1
		else:  # 돌을 제거해줄 필요가 없다면 기준이 되는 돌의 위치를 옮겨준다 
			loc = rock 
			tmp = min(tmp,diff)  # 기존 최솟값과 비교해줌
			
	if cnt > k:  # 최솟값을 너무 작게 잡은 경우
		right = mid - 1
	elif cnt < k:  # 최솟값은 적당히 잡았으나, 더 나은 결과를 얻을 수 있을 경우
		result = tmp
		left = mid + 1
	else:  # 최적의 경우
		result = tmp
		break
		
print(result)